・sourceでシェルを実行するのと普通に実行するのの違い
source [ファイル名]で実行すると、ファイルの内容が現在実行している
シェルの一部として実行されるが、
./[ファイル名]で実行すると、別なシェルとして実行される。

以下のようなtest.shがあるとする。
#!/bin/bash

aaa="aaaをセットした"
echo $aaa

sourceの場合
$ source test.sh
aaaをセットした 
$ echo $aaa
aaaをセットした 

## 現在実行しているシェルの一部として実行されているので、$aaaは呼び出し元にも反映される

普通に実行した場合
$ ./test.sh
aaaをセットした 
$ echo $aaa

## サブシェルとして別プロセスで実行されているので、$aaaには何もセットされていない
## ちなみにサブシェルで変数をエクスポートとしても親シェルでは認識できないが、
## 親シェルでエクスポートした変数はサブシェルで認識できる。

・名前が同じ場合の実行の優先順位
1. エイリアス
2. functionやif、forなどのキーワード
3. 関数
4. cdやtypeなどの組み込みコマンド
5. スクリプトと実行可能ファイル(PATH環境変数のディレクトリリストに基づく検索順位で)

・コマンドの種類を調べる
typeコマンドを使えば、そのコマンドがエイリアスなのか組み込み関数なのかがわかる
例：llコマンドを調べる
$ type -a ll
ll は `ls -l --color=auto' のエイリアスです

・関数のローカル変数
変数にlocalをつけて定義すると、関数内をスコープとするローカル変数を定義できる。
関数内での$1、$2は関数へのパラメータを表すローカル変数となる。
例：afunc.sh

function afunc
{
	local var1
	var1="in function"

	echo "param: ${0} ${1} ${2}"
	echo "var1: ${var1}"
}

var1="out function"
echo "var1: ${var1}"
afunc func_par1 func_par2
echo "var1: ${var1}"
# $0はグローバル変数
echo "param: ${0} ${1} ${2}"

結果：
$ ./afunc.sh scr1 scr1
var1: out function
param: ./afunc.sh func_par1 func_par2
var1: in function
var1: out function
param: ./afunc.sh scr1 scr1

・全パラメータを表す「$@」「$*」
$*	要素がスペースではなく、IFS環境変数の最初の１文字で区切られる。
$@  各要素がダブルコード括りで格納されている

例：param_all.sh
function countargs
{
	echo "$# args."
}

countargs "$@"
# 一つの引数として認識されてしましう
countargs "$*"

# このシェルだけIFS環境変数を変更（呼び出し元シェルには影響ない）
IFS=,
# 区切り文字が変換されて出力される
echo "$*"
echo "$@"

結果：
$ ./param_all.sh aaa bbb cc
3 args.
1 args.
aaa,bbb,cc
aaa bbb cc

・変数の記述と区切り
変数$abcは${abc}の省略形である。
変数$abcにアンダースコアをつけたい場合、省略形の形では実現できない。
$abc_	変数$abc_と判断される
${abc}_	変数$abcに_がつく。

変数名の後に英数字とアンダースコア以外の文字がきた場合は省略形でもOK
/$abc/$def/$hig		各変数を/で連結したものを表示

・変数の初期化、再定義と文字の切り出し
def_val.shを参照

・echoの特殊な使い方
echoに-nを使うと、改行を出力しない。-eを指定すると、「\n」を改行コードと認識する。
以下のecho文でvar1がnullの場合は、何も出力しない。
echo -n -e $var1

環境変数の$PATHのコロンを改行に変換して表示
echo -e ${PATH//:/'\n'}

・文字列の部分切り出し、置換
ext_chg_smp.shを参照

・文字列の長さ
${#var}

例：
var1="あかさたな"
echo ${#var1}		# 5と表示される。全角も1文字でカウント。

・bashの機能拡張
shoptコマンドのオプションをいろいろ変更すると、通常bashで出来ないことができる
「bash shopt」でググってみる。

・コマンドの結果を変数に格納
以下のようにすれば、コマンド結果を変数に格納できる(バッククォートと同じ働き)
var1=$(pwd)

入れ子にすることも可能
var1=$(ls $(pwd))

ファイル(abc.txt)の中身を変数に格納
var1=$(<abc.txt)

・ファイルの列を抜き出す
例：
$ cat abc.txt
abc|def|hig
jkl|lmn|opq
222|333|444

abc.txtから縦棒区切りの２列目を抜き出す
-dに区切り文字を指定する。縦棒はエスケープする必要あり。
$ cut -f2 -d\| abc.txt
def
lmn
333

デリミタがスペースの場合、シングルコートとかでくくる必要あり。
例：
$ who
yoko     pts/0        2017-11-07 20:31 (10.0.3.2)
$ who | cut -d' ' -f1
yoko

日付でファイル検索できる関数の例
util.shを参照

・bashのif文
if コマンド then と書くと、コマンドが正常終了した場合、if文の中に入る。
例：aaaディレクトリが存在するときのみ、成功しましたと出る。
if cd aaa/ 
then
	echo "cdが成功しました"
else
	echo "cdが失敗しました"
fi

※ thenを次の行に書かず、「if cd aaa/ ; then 」のような書き方も可。

・最後に実行したコマンドの戻り値
「$?」に格納されている。

・関数の戻り値
return文を使わない限り、関数及びシェルの戻り値は最後に実行したコマンドの戻り値となる。
シェルでは、sourceで実行された時以外はreturn文は使えない。かわりにexitを使う。

・終了ステータスの組み合わせによる実行可否(&& ||)
if 文１ && 文２
then
    ...
fi
上記の場合、文１の戻り値が0(正常終了)の場合のみ、文２が実行される。
if文がない場合でも、同様の動作をする。
文１ && 文２
if 文１; then
	文２
fi
上記は同じ挙動となる。

if 文１ || 文２
then
   ...
fi
上記の場合は、文１が正常終了すれば文２は実行されない。
文１が異常終了した時のみ、文２が実行される。

文１ || 文２
if 文１; then
else
	文２
fi

・if文とテストコマンド[]
testコマンドと[]は同じである。
下記は同じである。
test "aa"="aa"
[ "aa" = "aa" ]
※ブランケットの前後に半角スペースが無いとエラーになる。
また、testコマンドの演算子の前後にスペースを入れるとエラーになる。

・テストコマンドでの文字列比較
[ $str1 = $str2	]	# 等しい
[ $str1 != $str2 ]	# 等しく無い
[ $str1 > $str2	]	# str1が大きい
[ $str1 < $str2	]	# str2が大きい
[ -n $str1 ]	# 長さ0ではない
[ -z $str1 ]	# 長さ0である

・テストコマンドでの数値比較
[ $num1 -gt $num2	]	# num1が大きい
[ $num1 -lt $num2	]	# num2が大きい
[ $num1 -ge $num2	]	# num1がnum2以上
[ $num1 -le $num2	]	# num1がnum2以下
[ $num1 -eq $num2	]	# 等しい
[ $num1 -ne $num2	]	# 等しく無い

・テストコマンドでのファイル属性の確認
[ -a $file1 ]	# file1が存在する
[ ! -a $file1 ]	# file1が存在しない(!の前後にスペース必要)
[ -d $file1 ]	# file1が存在し、かつディレクトリ
[ -e $file1 ]	# file1が存在する(-aと同じ)
[ -f $file1 ]	# file1が存在し、かつファイル
[ -r $file1 ]	# file1が読み取り可能
[ -w $file1 ]	# file1が書き込み可能
[ -x $file1 ]	# file1がファイルなら実行可能、ディレクトリなら検索可能
[ $file1 -nt $file2 ] # file1がfile2よりあたらしい
[ $file1 -ot $file2 ] # file1がfile2より古い

・for文の基本構文
for 変数 in リスト; do
	何か処理
done

・for文の基本構文(その他)
for (( 初期値 ; 終了条件 ; 更新処理 ))
do
	処理
done
例：
for (( i=1; i<=3; i++ ))
do
	for (( j=1; j<=3; j++ ))
	do
		echo "iは$i、jは$j"
	done
done


・関数ではなく、コマンドを実行する
commandコマンドを使えば、同名の関数があってもコマンドを実行する。
例：ls関数が定義されている場合でもlsコマンドを実行する
command ls

・bashのcase文ではワイルドカードの指定が可能
例：
case $filename in
	*.jpg )	echo "JPEGファイルです" ;;
	*.tif )	echo "TIFファイルです" ;;
	*.gif )	echo "gifファイルです" ;;
	* ) echo "エラーです" 
	    exit 1 ;;
		
esac

・簡易メニュー
selectを使えばできる。
シェルプログラミング的にはあまり使い道はないかも？
入門bash P138参照。

・bashの位置パラメータ
shiftコマンドを使うと、引数を参照する位置パラメータを詰めることができる。
1=$2
2=$3
3=$4
 ...(全パラメータが一つずつ詰められる)
上記の処理が以下の1行でできる。(位置パラメータは読み専なので代入できないが)
shift

・コマンドオプションの取得方法
例：オブション-a -b -cを処理する例。それ以外のオプションを指定するとエラーになる。
    "ab:c:"を":ab:c:"とすると、それ以外のオプションを指定してもエラーにならない。
	(etopts_smp.sh参照)
while getopts "ab:c:" opt; do	# オプション文字列後に:があるとオプション引数がとれる
	case $opt in
	a ) 
		echo "aオプションが指定されました" ;;
	b ) 
		echo "bオプションが指定されました"
		echo "オプション引数${OPTARG}が指定されました" ;; 
	c ) 
		echo "bオプションが指定されました"
		echo "オプション引数${OPTARG}が指定されました" ;;
	* )   # \?でもよい
		echo "無効なオプションです" ;;
	esac
done
実行結果例：
$ ./getopts_smp.sh -b ddd -a xyz
bオプションが指定されました
オプション引数dddが指定されました
aオプションが指定されました

・関数名、変数名を調べるコマンド
declareコマンドを使うと関数を調べたり、配列を定義できたりする。
declare -F	# 関数名を列挙する

declare -i val1=10	# val1を整数型変数として定義する
declare -r val2="文字列" # 読み専として定義する
readonly val2="文字列" # 読み専として定義する(declare -rと同じ)

・bashの算術計算
二重かっこで式を囲むと、その式を算術計算と解釈する。
例：
var1=10
var2=5
var3=$(($var1+$var2))
echo $var3		# 15と出力される。

・bashの算術演算子
C言語同様なもの
++、--
<<	# 左に1ビットシフト
>>	# 右に1ビットシフト
& ビット単位の論理積
| ビット単位の論理和
~ ビット単位の論理否定
^ ビット単位の排他的論理和
** べき乗

・bashの算術計算(let)を使う
例：
# インクリメントが使える
let a=1
let a++
echo $a #=> 2

# 代入演算子が使える
a=2
let a*=3
echo $a #=> 6

# 三項演算子が使える
let a=1
let  a=(a ==2 ? 1 : 0)
echo $a  #=> 0

# 複数の式をまとめて記述できる
a=10
let a++ a++ a++
echo $a #=> 13

・bashのインクリメント「$(())を使う」
cnt=1
((cnt++))	# 代入しない場合は先頭に$をつけない
echo $cnt # => 2
cnt=$((cnt++))	
echo $cnt # => 2 変わらない。インクリメントする前の値が代入される
cnt=$((++cnt))	
echo $cnt # => 3
cnt=$((cnt += 1))	
echo $cnt # => 4

・配列の使用
例：
names[0]="ao"
names[1]="aka"
names[2]="midori"
または
names=([0]="ao" [1]="aka" [2]="midori")
または
names=("ao" "aka" "midori")
# 要素ごと出力
echo ${names[0]}  # $names[0]では正しい値が返らないことに注意
echo ${names[1]}
echo ${names[2]}
# for文で出力
for name in "${names[@]}"; do
	echo $name
done

・配列のインデスク、サイズを返す
例：
names=([0]="ao" [1]="aka" [5]="midori")
echo "${!names[@]}"  # => 0 1 5
echo "${#names[@]}"  # => 3  配列サイズを返す

・ヒアドキュメント
例：EOFまでの内容を"msgfile.txt"に出力
    EOFとEOFの間の文字列がcatの標準入力となり、$msgfileへリダイレクトする。
msgfile="msgfile.txt"
cat >> $msgfile << EOF
this is text of
our message
EOF

例：<<のあとに「-」をつけると、行頭のタブを削除してリダイレクトする
msgfile="msgfile.txt"
cat >> $msgfile <<- EOF
	this is text of
	our message
EOF

・printf
C言語にある、printfのような働きをするコマンド。echo文と違って自動的に改行されない。
例：
$ printf "%s %s \n" hello world
hello world

・空白埋めして文字を出力する
例：左に空白埋めする
$ printf "[%10s]\n" hello
[     hello]
例：右に空白埋めする
$ printf "[%-10s]\n" hello
[hello     ]

・0埋めして数値を出力する
$ printf "[%010d]\n" 100
[0000000100]
